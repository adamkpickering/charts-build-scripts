package auto

import (
	"strings"

	"github.com/blang/semver"
)

type versions struct {
	latest              *version
	latestRepoPrefix    *version
	toRelease           *version
	toReleaseRepoPrefix *version
}

type version struct {
	txt string
	svr *semver.Version
}

func (v *version) updateSemver() error {
	newSemver, err := semver.Make(v.txt)
	if err != nil {
		return err
	}
	v.svr = &newSemver
	return nil
}

// calculateNextVersion will calculate the next version to bump based on the latest version
// if the chart had a patch bump, it will increment the patch version for the repoPrefixVersion
// if the chart had a minor or major bump, it will increment the minor version for the repoPrefixVersion
// the major repoPrefixVersion is only bumped when Rancher version is bumped.
func (b *Bump) calculateNextVersion() error {
	// load versions and parse the repository prefix versions from them
	if err := b.loadVersions(); err != nil {
		return err
	}

	// TODO: check and parse the versions before building the new version
	//

	// build: toRelease full version
	targetVersion := b.versions.toReleaseRepoPrefix.txt + "+up" + b.versions.toRelease.txt
	targetSemver := semver.MustParse(targetVersion)
	b.releaseYaml.ChartVersion = targetVersion
	b.Pkg.AutoGeneratedBumpVersion = &targetSemver

	return nil
}

// loadVersions will load the latest version from the index.yaml and the version to release from the chart owner upstream repository
// rules:
//   - latest version may/may not contain a repoPrefixVersion
//   - to release version must not contain a repoPrefixVersion
func (b *Bump) loadVersions() error {
	b.versions = &versions{
		latest:              &version{},
		latestRepoPrefix:    &version{},
		toRelease:           &version{},
		toReleaseRepoPrefix: &version{},
	}

	// latestVersion and latestRepoPrefixVersion are the latest versions from the index.yaml
	// get the latest released version from the index.yaml (the first version is the latest; already sorted)
	latestUnparsedVersion := b.assetsVersionsMap[b.targetChart][0].Version
	if latestUnparsedVersion == "" {
		return errChartLatestVersion
	}

	// Latest version may/may not contain a repoPrefixVersion
	latestRepoPrefix, latestVersion, found := parseRepoPrefixVersionIfAny(latestUnparsedVersion)
	if found {
		b.versions.latestRepoPrefix.txt = latestRepoPrefix
		if err := b.versions.latestRepoPrefix.updateSemver(); err != nil {
			return err
		}
	}
	b.versions.latest.txt = latestVersion
	if err := b.versions.latest.updateSemver(); err != nil {
		return err
	}

	// TODO: toRelease version comes from the chart owner upstream repository

	// TODO: upstream/(to release version) must not contain a repoPrefixVersion

	// TODO: Check if latestVersion > versionToRelease before continuing

	return nil
}

func parseRepoPrefixVersionIfAny(unparsedVersion string) (repoPrefix, version string, found bool) {
	found = strings.Contains(unparsedVersion, "+up")
	if found {
		versions := strings.Split(unparsedVersion, "+up")
		repoPrefix = versions[0]
		version = versions[1]
	} else {
		version = unparsedVersion
	}

	return repoPrefix, version, found
}
